<blog>
	<post>
		<Date>July 13, 2021</Date>
		<Author>Jacob Bergdahl</Author>
		<Title>Will AI Replace Programmers</Title>
		<summary>
			<image_path>https://miro.medium.com/v2/resize:fit:720/format:webp/1*i8TEZH6GqSb_YtZB_r7zkw.jpeg</image_path>
			<text>OpenAI’s algorithms have opened the floodgates to code-generating AI, but how will it impact software developers? Well,Programmers will not be replaced any time soon</text>
		</summary>
		<body>
                  The complexity of being a programmer
                  First of all, I want to make it clear that none of the three aforementioned companies are marketing their products as replacements for humans. GitHub clearly describes their product Copilot as an                  “AI pair programmer,” and Debuild’s CEO Sharif Shameem has expressed disagreement with the idea that machines will replace programmers.
Rather, code-generating AI will work as an assistant for developers.I think some people might be quick to underestimate the complexity of what it means to be a software developer. Writing code itself is only a small part of what programmers do.

                 Understand business requirements
It cannot be understated how complex this task is. Understanding and translating the needs of the end-users into technical requirements, a user interface, and, ultimately, code, is one of the most challenging steps in software development.The product owner, the project manager, the designers, the developers, and the users all have a different image of the system they want.

                 Connect large tech stacks
Onboarding a new software developer into a complex project can take months. You would not believe the complexity of large-scale software projects. An online book store might be connected to a content management system (CMS, such as WordPress) through which administrators can add new content. On top of that, it might be integrated with an enterprise resource planning system (ERP) that stores all orders and products. The website might be built with React as a front-end programming language, with a handful of various dependencies to different libraries, and C# as a back-end language.

                 Debug erroneous code
Developers spend a lot of time debugging. I’ve definitely had days where I spent more time debugging code than writing new code, and I can guarantee that I’ll have to debug AI-generated code someday in the future.
Debugging large applications can be incredibly complex. And if you want an algorithm to write code and a human to debug the code generated by AI, then debugging sessions will only be even longer.

                 Communicate with stakeholders
As a developer, I need to communicate with different stakeholders using different vocabularies and techniques. I can use technical and complex terminology when I talk to the other developers in my team, while I need to explain functions in a non-technical and concrete manner to product owners. When I interact with clients, I need to be both confident and humble, and I have to make sure that I spend more time listening than talking. I need to hear and understand their concerns.

		</body>
	</post>
	<post>
		<Date>January 07, 2021</Date>
		<Author>Darryl Bartlett</Author>
		<Title>Build cross-platform apps with React Native</Title>
		<summary>
			<image_path>https://cdn.mos.cms.futurecdn.net/ss5szERZGvPmACDFUttvdS-970-80.jpg.webp</image_path>
			<text>React Native is a JavaScript library developed by Facebook.Not only can you use your existing knowledge of JavaScript but you can also use the same codebase to build for both iOS and Android.Building a signup functionality in React Native with this tutorial is a great starting point for your own app, and it could easily be improved upon by adding more screens, displaying errors on the front end and much more. </text>
		</summary>
		<body>
			
			1. Get started
			To get started building your React Native project, you will need to make sure that you have Node.js (opens in new tab) installed. You can then install the create-react-native-app command line utility by opening a new a terminal window and running the commands.

			
			2. Run your app
			Since you used create-react-native-app via the command line to build your project, you can use the Expo client app to test your application. All you need to do is download the app from the iOS App Store or Google Play Store and then scan the QR code from inside the terminal. You will need to make sure your device is on the same Wi-Fi network as your computer. You can also use the iPhone or Android simulator, if you have Xcode (opens in new tab) or Android Studio (opens in new tab) installed.


			3. Create a basic login
			Let’s start by adding something very basic. To add some text to your application, you will need to type.We are now going to create a fully functional login screen so that users can login, register for a new account, sign out and even reset their password. This is something you will see a lot in mobile apps, so it lays down a nice foundation for future projects.
			
			4. Set up Firebase and NativeBase
			We are going to start by installing three more libraries. The first is called Firebase (opens in new tab), which is what we will use for our user authentication, and the second is called NativeBase, which is a UI component library. The last one is called React Native Dialog Input, which enables us to display a dialogue box where users can enter text. Next, we will need to setup the Firebase config just underneath the import commands. You will need to go and setup an account with Firebase to get your various settings. You can do this by registering at Firebase (opens in new tab) and creating a new project. Remember that you will need to enable email and password authentication from the dashboard.

                        5. Build the container
The next step is to remove the section underneath render(), which was automatically placed there by React upon creating the project, and replace it with the following container to setup the login form. The form will contain a label and an input field for both an email address and password. We will also create three buttons: one to login, one to sign up and the final button is for when a user wants to reset their password.
			
			6. Set up the events
Firstly, we need to set up a constructor to set up the default state. The email and password default values will be set to empty. We will also set the value of isDialogVisible to false: this is going to be used for our password reset dialog box later on.

                        7. Make sign-up function
It’s now time to begin building out our functions. We will begin with the sign-up function (signUpUser), which will attempt to create a new user inside Firebase; if it succeeds, then we will display an onscreen alert to inform the user that their account has been set up. 
		</body>
	</post>
	<post>
		<Date>December 22, 2021</Date>
		<Author>DENNIS VAN DER VECHT</Author>
		<Title>What is Web 3.0</Title>
		<summary>
           <image_path>https://cdn.sanity.io/images/s7xbv9bz/production/6dbe0871953a18b6b6a5253294eb4d426f497173-4256x2832.jpg?rect=0,1,4256,2831&w=1920&h=1277&auto=format&fm=webp&q=100</image_path>
			<text>Web 3.0 has been given a number of enigmatic descriptions over the past few years, ranging from ‘the new age of the internet’ and 'the semantic web', through to ‘a decentralized version of the virtual world.’ So what exactly is it and how will it work? And why should business owners be thinking about it now? We take a deep dive into the subject, by reminding ourselves of the history and definitions of Web 1.0 and Web 2.0, and then looking at the three key ideas that underpin Web 3.0.......</text>
		</summary>
		<body>
			Web 1.0’s heyday was between 1990 and 2005, which was when the world wide web was in its infancy. Its main purpose was the sharing of information, which in itself was of course, a novelty at the time. It was the equivalent of millions of books and documents stored in one place, accessible by users across the world. There were many limitations of course. The websites of the day:
			Most web pages at the time were static, and were hosted on ISP-run web servers. This meant that while the information on these pages was useful, it wasn’t regularly updated. Therefore, users would have little reason to return to the same page more than once. However, we already saw the first intelligent search engines.
			Web 2.0 wants your personal data
            Web 2.0 heralded the dawn of online interaction. Starting in 2005, this ‘era’ has continued through to the present day. Where Web 1.0 was all about static pages, web 2.0 is about user generated content, with other users leaving their comments and posts on existing websites and sharing the information that they read on a range of social media platforms and blogs. The Web 2.0 period is also one in which mobile internet access has boomed, leading to content creation for consumers on the move, and the growing app market.
            Web 3.0 is the 'people-owned' internet
Web 3.0 is all about creating an internet which benefits every individual user who generates content, rather than just the owners of the platform of where this content is being published. This is because that very same user who produces the content is, or can easily become, a co-owner of this platform.
		</body>
	</post>
</blog>